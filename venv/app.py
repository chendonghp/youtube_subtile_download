import os
import sys
from threading import Thread

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, pyqtSlot, QThread, pyqtSignal
from YTubeSub import YTSubDownload, Video_ids
from YoutubePlaylistDownload import Ui_MainWindow


class DownloadThread(QThread):
    # python3,pyqt5与之前的版本有些不一样
    #  通过类成员对象定义信号对象
    trigger = pyqtSignal(str)
    def __init__(self, target:object,name :str):
        super().__init__()
        self.target=target
        self.name=name

    def __del__(self):
        self.wait()

    def run(self):
        # 处理你要做的业务逻辑，这里是通过一个回调来处理数据，这里的逻辑处理写自己的方法
        # 可以在这里写信号焕发
        self.target()
        self.trigger.emit(self.name+ ": 下载完成.")


class MainWindowUIClass(Ui_MainWindow):
    dir=""
    playlist_title=""
    video_ids=[]
    def __init__(self):
        '''Initialize the super class
        '''
        super().__init__()
        self.vids=Video_ids(playlist_url="")


    def setupUi(self, MW):
        ''' Setup the UI of the super class, and add here code
        that relates to the way we want our UI to operate.
        '''
        super().setupUi(MW)
        self.url_text.setText("https://www.youtube.com/watch?v=upinO0f20QY&list=PL5iJcUfx7xTdBPrH6DJBMnF8vZNvNslkO")
        self.dir_text.setText(".")
        # close the lower part of the splitter to hide the
        # debug window under normal operations

    def debugPrint(self, msg):
        '''Print the message in the text edit at the bottom of the
        horizontal splitter.
        '''
        self.log.append(msg)

    # def check(self):
    #     if self.sender().isChecked():
    #         self.debugPrint('创建')
    #     else:
    #         self.debugPrint('不创建')

    def browse_slot(self):
        dir= QtWidgets.QFileDialog.getExistingDirectory(parent=None,
                                                        caption="choose directory",
                                                        directory='.',
                                                        options=QtWidgets.QFileDialog.ShowDirsOnly
                                                        )
        MainWindowUIClass.dir=dir
        self.dir_text.setText(dir)
        self.debugPrint( "字幕输出目录为: "+dir )

    def dir_pressed_return_slot(self):
        MainWindowUIClass.dir=self.dir_text.text()
        if not os.path.isdir(MainWindowUIClass.dir):
            # self.la = QLabel('这里将会显示我们选择的按钮信息', self)
            msgBox=QtWidgets.QMessageBox()
            msgBox.setText("Directory "+MainWindowUIClass.dir +" doesn't exist. Create it!")
            msgBox.setIcon(QtWidgets.QMessageBox.Warning)
            create = msgBox.addButton('创建', QMessageBox.AcceptRole)
            escape = msgBox.addButton('取消', QMessageBox.RejectRole)
            msgBox.setDefaultButton(create)
            # cb = QCheckBox('记住此操作')
            # msgBox.setCheckBox(cb)
            # cb.stateChanged.connect(self.check)
            reply = msgBox.exec()
            if reply == QMessageBox.AcceptRole:
                self.debugPrint('你选择了创建！')
                os.mkdir(MainWindowUIClass.dir)
            elif reply == QMessageBox.RejectRole:
                self.debugPrint('你选择了取消！')
        self.debugPrint( "字幕输出目录为: " +MainWindowUIClass.dir)

    def url_return_pressed_slot(self):
        self.vids.playlist_url=self.url_text.text()
        self.debugPrint( "Playlist URL为: "+ self.vids.playlist_url)

    def resolve_playlist_slot(self):
        try:
            self.vids.playlist_url = self.url_text.text()
            vids = Video_ids(self.vids.playlist_url)
            MainWindowUIClass.playlist_title, MainWindowUIClass.video_ids  =vids.get_video_ids()
        except Exception as e:
            self.debugPrint("解析错误: "+str(e))
        self.debugPrint( "Playlist 标题为: "+ MainWindowUIClass.playlist_title +"\n现在可以点击下载按钮下载.")

    def download_subs_slot(self):
        try:
            MainWindowUIClass.dir=os.path.join(MainWindowUIClass.dir,MainWindowUIClass.playlist_title)
            self._thread=[]
            for i,vid in enumerate(MainWindowUIClass.video_ids):
                v=YTSubDownload(vid, dir=MainWindowUIClass.dir, proxies=None)
                self._thread.append(DownloadThread(target=v.sub_download,name=v.video_title))
            for i in range(len(self._thread)):
                self.debugPrint(self._thread[i].name + " 开始下载.")
                self._thread[i].start()
                self._thread[i].trigger.connect(self.download_completed)
        except Exception as e:
            self.debugPrint( "下载出错: "+str(e) )

    def download_completed(self,msg):
        self.debugPrint(msg)

def app():
    """
    This is the MAIN ENTRY POINT of our application.  The code at the end
    of the mainwindow.py script will not be executed, since this script is now
    our main program.   We have simply copied the code from mainwindow.py here
    since it was automatically generated by '''pyuic5'''.

    """
    app = QtWidgets.QApplication(sys.argv)
    app.setStyle('Fusion')
    app.setWindowIcon(QtGui.QIcon('字幕.png'))
    MainWindow = QtWidgets.QMainWindow()
    ui = MainWindowUIClass()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

app()